<!doctype html>
<html>
<head> 
    <meta charset="utf-8">
    <link rel="stylesheet" href="binary.css" type="text/css">
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
</head>
<style>
body, html, figure { margin: 0; padding: 0; }
html { background: #fafbf9; }
body, figure {
    display: grid;
    grid-template-columns: [start] 1fr repeat(10, [content] 66px) 1fr [end];
    grid-column-gap: 22px;
    grid-row-gap: 8px;
    grid-template-rows: minmax(20px, auto);
}
.bin-caption {
    font-family: helvetica, arial, sans-serif;
    font-size: 13px;
    color: #265488;
}
.caption {
    font-family: helvetica, arial, sans-serif;
    font-size: 14px;
    color: #a4b1b0;
    letter-spacing: 0.2px;
}
p.main {
    grid-column: content 2 / content 9;
    font-family: Georgia;
    font-size: 20px;
    color: #355f5b;
    margin: 0;
    line-height: 25px;
    letter-spacing: 0.12px;
    word-spacing: 1.5px;
    margin-bottom: 8px;
}
code {
    color: #484848;
    font-family: Monaco, Menlo, courier, monospace;
    font-size: 15px;
}
h1, h2, h3, h4 { font-family: helvetica neue, Roboto, sans-serif; margin: 0; }
h1.section-title {
    color: #2c4e4c;
    font-size: 34px;
    margin-bottom: 12px;
    font-weight: 400;
    letter-spacing: 0.5px;
    margin-top: 30px;
}
h2.section-discussion {
    color: #325a57;
    font-weight: 500;
    font-size: 20px;
    letter-spacing: 0.5px;
}
figure.blend-bg {
    grid-column: start / end;
    background: #fafbf9;
    padding-bottom: 28px;
}
pre.prettyprint, code.prettyprint {
    border: none;
    background: #efebe7;
    border-radius: 2px;
    font-size: 13px;
}
pre.header {
    margin-bottom: 20px;
    margin-top: 20px;
}
.pln, .pun, .lit { color: #44445d; }
.com { color: #cecccc; }
.typ { color: #da5892; }
.kwd { color: #6e6e80; }
h4 span.desc-title {
    font-size: 12px;
    text-transform: uppercase;
    font-weight: 500;
    text-decoration: underline;
    letter-spacing: 0.7px;
    color: #2c4e4c;
}
h4 span.desc-info {
    font-size: 14px;
    font-weight: 400;
    letter-spacing: 0.2px;
    color: #2c4e4c;
}
span.num {
    font-family: times, serif;
}
span.title {
    text-decoration: underline;
}
h3.reference {
    margin-top: 16px;
    margin-bottom: 12px;
    line-height: 18px;
}
h3.reference a {
    color: #AAACA5;
    font-size: 14px;
    font-family: helvetica neue;
    font-weight: 300;
    text-decoration: None;
    letter-spacing: 0.5px;
}
h3.reference a:hover {
    text-decoration: underline;
}
code.aside {
    color: #265488;
    font-size: 12px;
}
</style>

<body>

    <svg style="grid-column: content 2 / content 10; margin-top: 40px;" width="322px" height="48px" viewBox="0 0 322 48" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
        <desc>Created with Sketch.</desc>
        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
            <g transform="translate(-283.000000, -107.000000)">
                <g transform="translate(283.000000, 107.000000)">
                    <rect fill="#CADCF6" x="0" y="0" width="40" height="47.0588235" rx="2"></rect>
                    <rect fill="#CADCF6" x="47" y="0" width="40" height="47.0588235" rx="2"></rect>
                    <text font-family="Monaco" font-size="36" font-weight="normal" letter-spacing="0.419999987" fill="#407CD2">
                        <tspan x="10" y="36">D</tspan>
                    </text>
                    <text font-family="Monaco" font-size="36" font-weight="normal" letter-spacing="0.419999987" fill="#407CD2">
                        <tspan x="57" y="36">A</tspan>
                    </text>
                    <rect fill="#CADCF6" x="94" y="0" width="40" height="47.0588235" rx="2"></rect>
                    <text font-family="Monaco" font-size="36" font-weight="normal" letter-spacing="0.419999987" fill="#407CD2">
                        <tspan x="104" y="36">T</tspan>
                    </text>
                    <rect fill="#CADCF6" x="141" y="0" width="40" height="47.0588235" rx="2"></rect>
                    <text font-family="Monaco" font-size="36" font-weight="normal" letter-spacing="0.419999987" fill="#407CD2">
                        <tspan x="151" y="36">A</tspan>
                    </text>
                    <rect fill="#DE74AE" x="188" y="0" width="40" height="47.0588235" rx="2"></rect>
                    <text font-family="Monaco" font-size="36" font-weight="normal" letter-spacing="0.419999987" fill="#B1397B">
                        <tspan x="198" y="36">L</tspan>
                    </text>
                    <rect fill="#DE74AE" x="235" y="0" width="40" height="47.0588235" rx="2"></rect>
                    <text font-family="Monaco" font-size="36" font-weight="normal" letter-spacing="0.419999987" fill="#B1397B">
                        <tspan x="245" y="36">A</tspan>
                    </text>
                    <rect fill="#DE74AE" x="282" y="0" width="40" height="47.0588235" rx="2"></rect>
                    <text font-family="Monaco" font-size="36" font-weight="normal" letter-spacing="0.419999987" fill="#B1397B">
                        <tspan x="292" y="36">B</tspan>
                    </text>
                </g>
            </g>
        </g>
    </svg>

    <h3 style="grid-column: content 2/ content 10;" class="reference">
    <a href="http://csapp.cs.cmu.edu/3e/labs.html">Computer Systems: A Programmer's Approach</a> <br>
    <a href="https://www.cs.cmu.edu/~213/">CMU 15213</a> 
    </h3>

    <p class="main">
    The following four solution writeups are from "Data Lab" from
    Carnegie Mellon's 
    <span class="title">Computer Systems: A Programmer's Perspective</span>.
    </p>

    <p class="main">
    <code>int</code>, <code>unsigned</code>, and 
    <code>float</code> are <span class="num">32</span>-bit encoded, and one byte
    is equal to <span class="num">8</span> bits.
    </p>

    <p class="main">
    <code>TMIN</code> and <code>TMAX</code> refer to the minimum and maximum
    respectively for a <span class="num">32</span>-bit two's complement encoding. 
    <code>MSB</code> and <code>LSB</code> refer to the most significant
    bit of a set of bits and the least significant bit of a set of bits
    respectively.
    </p>

    <h1 style="grid-column: content 2 / content 6;" class="section-title"><a name="getByte">getByte</a></h1>

    <h4 style="grid-column: content 2 / content 10;" >
      <span class="desc-title">Description</span></br>
      <span class="desc-info">Return byte <code>n</code> of <code>x</code>, indexed from zero.</span></br>
    </h4>

    <h4 style="grid-column: content 2 / content 10;">
      <span class="desc-title">Legal Ops</span><br>
      <span class="desc-info"><code>~  |  &lt&lt  &gt&gt  &  ^  ! </code></span>
    </h4>

    <h4 style="grid-column: content 2 / content 10;">
      <span class="desc-title">Max ops</span><br>
      <span class="desc-info"><span class="num">8</span></span><br>
    </h4>

    <pre style="grid-column: content 2 / content 9;" class="prettyprint header">
        <code class="language-c" >
    import &ltassert.h&gt

    int getByte(int x, int n) {
       //...
    }

    int main(int argc, char **argv) {
        assert(getByte(0xDEADBEEF, 0) == 0xEF);
        assert(getByte(0xDEADBEEF, 1) == 0xBE);
        assert(getByte(0xDEADBEEF, 2) == 0xAD);
        assert(getByte(0xDEADBEEF, 3) == 0xDE);

        return 0;
    }
        </code>
    </pre>

    <h2 style="grid-column: content 2 / content 10;" class="section-discussion">Aligning the byte</h2>
    <p class="main"></p>
    <p class="main">
    Consider <code>x = 0xF0F0F0F0</code>. The highlighted bits represent byte <code>n</code>, 
    for <code>n</code> in the range <span class="num">0..3</span>.
    </p>
    <p class="main"></p>
    <figure class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">n=0</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 2;" hex="0xf0f0f0f0" hi="0x000000FF" isfloat="0">
        </bin-ary-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 4;" class="bin-caption">n=1</div> 
        <bin-ary-svg style="grid-column:content 2 / content 10; grid-row: 4;" hex="0xf0f0f0f0" hi="0x0000FF00" isfloat="0">
        </bin-ary-svg>
        
        <div style="grid-column: content 1 / content 2; grid-row: 6;" class="bin-caption">n=2</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 6;" hex="0xf0f0f0f0" hi="0x00FF0000" isfloat="0">
        </bin-ary-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">n=3</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 8;" hex="0xf0f0f0f0" hi="0xFF000000"  isfloat="0">
        </bin-ary-svg>
    </figure>

    <p class="main"></p>
    <p class="main">
    In order to return byte <code>n</code> from <code>x</code>,  a 
    <span class="num">4</span>-byte value, byte <code>n</code> must be 
    relocated to byte <span class="num">0</span>. 
    We can achieve this transformation by shifting the highlighted bits by 
    <code>n</code> bytes.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1/content 2; grid-row: 2;" class="bin-caption">shift 0 bytes</div> 

        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0xf0f0f0f0" y="0x0" op=">>" hix="0xFF" hires="0xFF">
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">shift 1 bytes</div> 

        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 5;" x="0xf0f0f0f0" y="0x8" op=">>" hix="0xFF00" hires="0xFF">
        </op-2a-svg>

        <div style="grid-column: content 1/ content 2; grid-row: 8;" class="bin-caption">shift 2 bytes</div> 

        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 8;" x="0xf0f0f0f0" y="0x10" op=">>" hix="0xFF0000" hires="0xFF">
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 11;" class="bin-caption">shift 3 bytes</div> 

        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 11;" x="0xf0f0f0f0" y="0x18" op=">>" hix="0xFF000000" hires="0xFF">
        </op-2a-svg>
    </figure>

    <p class="main"></p>
    <p class="main">
    Thus, a right shift of <code>n</code> bytes relocates byte <code>n</code>
    of <code>x</code> to byte <span class="num">0</span>.
    However, shifting by bytes is not an operation, we can only
    shift by bits. Therefore, the number of shifts must be calculated from 
    <code>n</code>.
    </p>
    
    <p class="main">
    Applying the simple function <code>f(n) = 8*n</code> to <code>n</code> maps 
    bytes-to-shift to bits-to-shift for a given <code>n</code>, but
    multiplication is not a legal operator. We need to calculate the shift
    according to <code>f(n) = 8*n</code> while using only the legal operators.
    Let's look at the binary representation of <code>n*8</code> for 
    <code>n</code> over the range  
    <span class="num">0..3</span>.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1/content 2; grid-row: 2;" class="bin-caption">8*0</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 2;" hex="0x00000000" isfloat="0">
        </bin-ary-svg>

        <div style="grid-column: content 1/content 2; grid-row: 3;" class="bin-caption">8*1</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row:3;" hex="0x00000008" isfloat="0">
        </bin-ary-svg>

        <div style="grid-column: content 1/content 2; grid-row: 4;" class="bin-caption">8*2</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row:4;" hex="0x00000010" isfloat="0">
        </bin-ary-svg>

        <div style="grid-column: content 1/content 2; grid-row: 5;" class="bin-caption">8*3</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row:5;" hex="0x00000018" isfloat="0">
        </bin-ary-svg>
    </figure>

    <p class="main">
    How do those binary representations relate to <code>n</code>? 
    </p>

    <figure  class="blend-bg">
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 2;" hex="0x00000000" isfloat="0">
        </bin-ary-svg>

        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 3;" hex="0x00000001" isfloat="0">
        </bin-ary-svg>

        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 4;" hex="0x00000002" isfloat="0">
        </bin-ary-svg>

        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 5;" hex="0x00000003" isfloat="0">
        </bin-ary-svg>
    </figure>

    <p class="main">
    We can rewrite our function
    as <code>f(n) = 2<sup>3</sup> * n </code>. The mapping can be
    expressed as multiplying <code>n</code> by three powers of two,
    which is equivalent to shifting <code>n</code> to the left three times. 
    (Since we have a fixed range for <code>n</code>, we do not need to
    worry about overflow.)

    <figure  class="blend-bg">
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0x00000000" y="0x3" op="<<" hix="0x03" hires="0x18">
        </op-2a-svg>

        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 5;" x="0x00000001" y="0x3" op="<<" hix="0x03" hires="0x18">
        </op-2a-svg>

        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 8;" x="0x00000002" y="0x3" op="<<" hix="0x03" hires="0x18">
        </op-2a-svg>

        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 11;" x="0x00000003" y="0x3" op="<<" hix="0x03" hires="0x18">
        </op-2a-svg>
    </figure>

    <h2 style="grid-column: content 2 / content 10;" class="section-discussion">Removing Unwanted Bits</h2>

    <p class="main">
    We have an operation to shift byte <code>n</code> to byte
    <span class="num">0</span>, but if <code>x</code> is negative, at least one
    bit in bytes <span class="num">1..3</span> will be set. We need a mask 
    that preserves byte <span class="num">0</span> but converts all other 
    bits to zeros.
    </p>

    <p class="main">
    Since constants up to one byte are legal, we can use <code>0xFF</code>
    to mask off the upper three bytes.
    </p>

    <figure class="blend-bg">
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0xdeadbeef" y="0xFF" op="&" >
        </op-2a-svg>

        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 5;" x="0xf0f0f0f0" y="0xFF" op="&" >
        </op-2a-svg>

        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 8;" x="0xffffffff" y="0xFF" op="&" >
        </op-2a-svg>

        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 11;" x="0x00000000" y="0xFF" op="&" >
        </op-2a-svg>
    </figure>

    <p class="main">Mapping byte <code>n</code> to byte <span class="num">0</span>
    and then masking off the upper three bytes can be expressed with three operators.
    </p>

    <pre style="grid-column: content 2 / content 9;" class="prettyprint language-c">
    <code>
  int getByte(int x, int n) {
      return (x >> (n << 3)) & 0xFF;
  }
    </code>
    </pre>

    <!-- isPositive -->
    <h1 style="grid-column: content 2 / content 6;" class="section-title"><a name="isPositive">isPositive</a></h1>

    <h4 style="grid-column: content 2 / content 10;" >
      <span class="desc-title">Description</span></br>
      <span class="desc-info">
          Return <span class="num">1</span> if <code>x</code> is greater than
          <span class="num">0</span>, <span class="num">0</span> otherwise.
      </span>
    </h4>

    <h4 style="grid-column: content 2 / content 10;" >
      <span class="desc-title">Legal Ops</span></br>
      <span class="desc-info"><code>~  |  &lt&lt  &gt&gt  &  ^  !</code></span>
    </h4>

    <h4 style="grid-column: content 2 / content 10;" >
      <span class="desc-title">Max ops</span></br>
      <span class="desc-info"><span class="num">8</span></span>
    </h4>

    <pre style="grid-column: content 2 / content 9;" class="prettyprint header">
        <code class="language-c" >
    import &ltassert.h&gt

    int isPositive(int x) {
       //...
    }

    int main(int argc, char **argv) {
        assert(isPositive(0x1) == 0x1);
        assert(isPositive(0x0) == 0x0);
        assert(isPositive(0x80000000) == 0x0);
        assert(isPositive(0x7FFFFFFF) == 0x1);
        assert(isPositive(0xFFFFFFFF) == 0x0);

        return 0;
    }
        </code>
    </pre>

    <h2 style="grid-column: content 2 / content 10;" class="section-discussion">Not Negative</h2>

    <p class="main">
    Mapping positive to <span class="num">1</span> and negative to 
    <span class="num">0</span> is straightfoward: the sign is encoded in the 
    <code>MSB</code>.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">positive</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 2;" hex="0x70F0F0F0" hi="0x80000000" isfloat="0">
        </bin-ary-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 3;" class="bin-caption">positive</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 3;" hex="0x7FFFFFFF" hi="0x80000000" isfloat="0">
        </bin-ary-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 4;" class="bin-caption">positive</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 4;" hex="0x00000080" hi="0x80000000" isfloat="0">
        </bin-ary-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">negative</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 5;" hex="0x80000000" hi="0x80000000" isfloat="0">
        </bin-ary-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 6;" class="bin-caption">negative</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 6;" hex="0xFFFF0000" hi="0x80000000" isfloat="0">
        </bin-ary-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 7;" class="bin-caption">negative</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 7;" hex="0xF0F0F0F0" hi="0x80000000" isfloat="0">
        </bin-ary-svg>
    </figure>

    <p class="main">
    Shifting the sign bit to the <code>LSB</code> produces <span class="num">-1</span> for 
    negative numbers and <span class="num">0</span> for positive numbers.
    </p>
    
    <figure  class="blend-bg">
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:2" x="0xf0f0f0f0" y="0x1F" op=">>" >
        </op-2a-svg>

        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:5" x="0x7fffffff" y="0x1F" op=">>" >
        </op-2a-svg>
    </figure>

    <p class="main">
    Adding one after the shift <code>(x >> 31) + 1</code> will return 
    <span class="num">1</span> for positive numbers and 
    <span class="num">0</span> for negative numbers. Thus
    the result is a boolean that represents <code>x >= 0</code> and will
    be referred to as <code>notNeg</code>.

    <h2 style="grid-column: content 2 / content 10;" class="section-discussion">Not Zero</h2>

    <p class="main">
    <code>notNeg</code> is not a complete solution as we want 
    <code>isPositive</code> to return 1 when <code>x</code> is 
    not negative and not zero,
    and so far all we have is <code>notNeg</code>, which
    will incorrectly return 1 if <code>x</code>
    is not negative or if <code>x</code> is zero.
    </p>

    <p class="main">
    We need a boolean that is true when <code>x</code> is not zero
    and false otherwise, which we'll call <code>notZero</code>.

    If any bit is set, <code>notZero</code> should be 
    <span class="num">1</span>, and if no bits are set 
    <code>notZero</code> should be <span class="num">0</span>. A
    single logical negation <code>!x</code> results in a boolean that is true
    when <code>x</code> is zero, false otherwise. We want the opposite, so 
    we apply another logical negation to get <code>notZero</code>. 
    </p>

    <p class="main">
    Applying <code>notNeg</code> and <code>notZero</code> to a negative number.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">dragging sign bit</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:2" x="0xf0f0f0f0" y="0x1F" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">not negative</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:5" x="0xffffffff" y="0x1" op="+" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">not zero</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row:8" hex="0x1">
        </bin-ary-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 11;" class="bin-caption">not negative and not zero</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:11;" x="0x0" y="0x1" op="&" >
        </op-2a-svg>
    </figure>

    <p class="main">
    Applied to a positive number.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">dragging sign bit</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:2" x="0x7fffffff" y="0x1F" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">not negative</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:5" x="0x00000000" y="0x1" op="+" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">not zero</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row:8" hex="0x1">
        </bin-ary-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 11;" class="bin-caption">not negative and not zero</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:11;" x="0x1" y="0x1" op="&" >
        </op-2a-svg>
    </figure>

    <p class="main">
    Applied to zero.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">dragging sign bit</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:2" x="0x0" y="0x1F" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">not negative</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:5" x="0x00000000" y="0x1" op="+" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">not zero</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row:8" hex="0x0">
        </bin-ary-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 11;" class="bin-caption">not negative and not zero</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:11;" x="0x1" y="0x0" op="&" >
        </op-2a-svg>
    </figure>

    <pre style="grid-column: content 2 / content 9;" class="prettyprint language-c">
    <code>
  int isPositive(int x) {
      int notNeg = (x >> 0x1F) + 1;
      int notZero = !!x;
      return notNeg & notZero;
  }
    </code>
    </pre>
    </p>
    <p class="main"></p>

    <!-- logicalShift -->
    <h1 style="grid-column: content 2 / content 6;" class="section-title"><a name="logicalShift">logicalShift</a></h1>

    <h4 style="grid-column: content 2 / content 10;" >
      <span class="desc-title">Description</span></br>
      <span class="desc-info">Right shift fill with zeros.</span>
    </h4>

    <h4 style="grid-column: content 2 / content 10;" >
      <span class="desc-title">Legal Ops</span></br>
      <span class="desc-info"><code>~  |  &lt&lt  &gt&gt  &  ^  !</code></span>
    </h4>

    <h4 style="grid-column: content 2 / content 10;" >
      <span class="desc-title">Max ops</span></br>
      <span class="desc-info">20</span>
    </h4>

    <pre style="grid-column: content 2 / content 9;" class="prettyprint header">
        <code class="language-c" >
    import &ltassert.h&gt

    int logicalShift(int x, int n) {
       //...
    }

    int main(int argc, char **argv) {
        assert(logicalShift(0x80000000, 0x0) == 0x80000000);
        assert(logicalShift(0x80000000, 0x1) == 0x40000000);
        assert(logicalShift(0x1, 0x1) == 0x0);
        assert(logicalShift(0xFF, 0x4) == 0xF);

        return 0;
    }
        </code>
    </pre>

    <h2 style="grid-column: content 2 / content 10;" class="section-discussion">Building a Mask</h2>

    <p class="main">
    A logical shift is equivalent to an arithmetic shift with the exception 
    that for negative numbers, the <code>n</code> most significant bits are zeros 
    instead of ones. For example, <code>
    logicalShift(0xFF000000,0x3)</code> should produce <code>0x1FE00000</code>.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">arithmetic shift</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0xFF000000" y="0x3" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">desired</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 5;" hex="0x1FE00000" isfloat="0">
        </bin-ary-svg>

    </figure>

    <p class="main">
    Since positive numbers require no modification from an arithmetic shift,
    we'll start by considering how to transform negative numbers. (We'll
    have to ensure that the process does not effect positive numbers.) 
    </p>

    <p class="main">
    If <code>x</code> is arithmetically shifted by <code>n</code>, and a mask
    of size <code>n</code> is used to zero the <code>n</code> most significant
    bits, the result is <code>x</code> logically shifted by <code>n</code>. 
    
    To begin, we need to to build a mask of size <code>n</code>.
    </p>

    <p class="main">
    Right shifting <code>TMIN</code> by
    <code>n - 1</code>, produces a mask of size <code>n</code>, which
    will be referred to as <code>mask</code>.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">n = 2</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0x80000000" y="0x1" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">n = 3</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 5;" x="0x80000000" y="0x2" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">n = 5</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 8;" x="0x80000000" y="0x4" op=">>" >
        </op-2a-svg>
    </figure>

    <h2 style="grid-column: content 2 / content 10;" class="section-discussion">Zeroing Bits</h2>

    <p class="main">
    The <code>n</code> upper bits of a negative <code>x</code> right shifted
    by <code>n</code> can be converted to zeros by xoring shifted 
    <code>x</code> and <code>mask</code>.
    </p>
    
    <p class="main">
    A logical shift of <code>0xFF000000</code> by <code>0x3</code>, as noted above, should
    produce <code>0x1FE00000</code>.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">arithmetic shift x</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0xFF000000" y="0x3" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 5;" x="0x80000000" y="0x2" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">zero upper n bits</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 8;" x="0xFFE00000" y="0xE0000000" op="^" >
        </op-2a-svg>
    </figure>

    <p class="main">
    The result is <code>0x1FE00000</code>, as expected,
    however, recall that the right shift of positive numbers cannot
    be effected by the transformations performed to logically shift negative 
    numbers. Xoring <code>mask</code> and a positive number will convert 
    the <code>n</code> most significant bits to ones, which is incorrect
    when <code>n > 0</code>.
    </p>
    
    <h2 style="grid-column: content 2 / content 10;" class="section-discussion">Mask from a Boolean</h2>

    <p class="main">
    So as to not affect shifting postive numbers, <code>mask</code> should only 
    be non-zero when <code>x</code> is negative. We'll build the mask from a boolean 
    bit that represents <code>x < 0</code>.
    </p>

    <p class="main">
    For example, if <code>x = 0x7FFFFFFF</code> (<code>TMAX</code>), and 
    <code>n = 3</code>, the <code>mask</code> is <code>0</code>.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">shift sign bit</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0x7FFFFFFF" y="0x1F" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">bit for mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 5;" x="0x00000000" y="0x1" op="&" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">boolean TMIN</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 8;" x="0x00000000" y="0x0000001F" op="<<" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 11;" class="bin-caption">mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 11;" x="0x00000000" y="0x2" op=">>" >
        </op-2a-svg>
    </figure>

    <p class="main">
    If <code>x = 0xF0000000</code>, and <code>n = 3</code>,
    the resulting mask is <code>0xE0000000</code>.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">shift sign bit</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0xF0000000" y="0x1F" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">bit for mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 5;" x="0xFFFFFFFF" y="0x1" op="&" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">boolean TMIN</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 8;" x="0x1" y="0x1F" op="<<">
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 11;" class="bin-caption">mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 11;" x="0x80000000" y="0x2" op=">>" >
        </op-2a-svg>
    </figure>


    <p class="main">
    Combining the logic to create the boolean bit, the logic to create 
    <code>mask</code>, and the logic to zero the upper bits results in 
    <code>VERSION 1</code>.
    </p>

    <pre style="grid-column: content 2 / content 9;" class="prettyprint header">
        <code class="language-c" >
    // VERSION 1
    int logicalShift(int x, int n) {
        int negativeOne = ~0x0;
        int thirtyOne = 0x1F;
        int needMask = ((x >> thirtyOne) & 0x1);
        int mask = (needMask << thirtyOne) >> (n + (negativeOne));
        return (x >> n) ^ mask;
    }
        </code>
    </pre>

    <p class="main">
    Let's step through the logic given a negative <code>x</code> and a non-zero 
    <code>n</code>, specifically <code>logicalShift(0x80000000, 3)</code>.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">need mask?</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0x80000000" y="0x1F" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">convert to bool</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 5;" x="0xFFFFFFFF" y="0x1" op="&" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 8;" x="0x80000000" y="0x2" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 11;" class="bin-caption">shift x</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 11;" x="0x80000000" y="0x3" op=">>">
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 14;" class="bin-caption">apply mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 14;" x="0xF0000000" y="0xE0000000" op="^">
        </op-2a-svg>
    </figure>

    <p class="main">
    That works. Let's try a case where <code> x > 0 </code> and <code> n > 0
    </code>, specifically <code>logicalShift(0xFF, 4)</code>.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">need mask?</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0x000000FF" y="0x1F" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">convert to bool</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 5;" x="0x00000000" y="0x1" op="&" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 8;" x="0x00000000" y="0x4" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 11;" class="bin-caption">shift x</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 11;" x="0x000000FF" y="0x4" op=">>">
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 14;" class="bin-caption">apply mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 14;" x="0x0000000F" y="0x00000000" op="^">
        </op-2a-svg>
    </figure>

    <p class="main">
    Also works. Let's try a case where <code>x = 0</code>, specifically <code>
    logicalShift(0x80000000, 0)</code>
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">need mask?</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0x80000000" y="0x1F" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">convert to bool</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 5;" x="0xFFFFFFFFF" y="0x1" op="&" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 8;" x="0x80000000" y="0xFFFFFFFF" op=">>" >
        </op-2a-svg>
    </figure>

    <p class="main">
    There is a bug. In the line 
    <code>int mask = (needMask << thirtyOne) >> (n + (negativeOne));</code>, when
    <code>n = 0</code>, we'll be shifting right shifting by a negative number,
    which results in undefined behavior.
    </p>

    <p class="main">
    We only need <code>n - 1</code> shifts when <code>n > 0</code>. As such,
    we want <code>n > 0</code> to map to <span class="num">-1</span>, and <code>n == 0</code> to map to
    zero. That mapping is added to produce <code>VERSION 2</code>.
    </p>

    <pre style="grid-column: content 2 / content 9;" class="prettyprint header">
        <code class="language-c" >
    // VERSION 2
    int logicalShift(int x, int n) {
        int negativeOne = ~0x0;
        int offset = (!n) + negativeOne;
        int thirtyOne = 0x1F;
        int needMask = ((x >> thirtyOne) & 0x1);
        int mask = (needMask << thirtyOne) >> (n + (offset));
        return (x >> n) ^ mask;
    }
        </code>
    </pre>

    <p class="main">
    In <code>VERSION 2</code>, we only shift if <code>n > 0</code>. Let's retry<code>
    logicalShift(0x80000000, 0)</code>.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">need mask?</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0x80000000" y="0x1F" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">convert to bool</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 5;" x="0xFFFFFFFFF" y="0x1" op="&" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 8;" x="0x80000000" y="0x0" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 11;" class="bin-caption">shift x</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 11;" x="0x80000000" y="0x0" op=">>">
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 14;" class="bin-caption">apply mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 14;" x="0x80000000" y="0x80000000" op="^">
        </op-2a-svg>
    </figure>

    <p class="main">
    That's not right either. We only need our mask if <code>n > 0</code>. We
    modify our <code>needMask</code> bool bit to reflect we only want a mask
    when <code>x < 0</code> and <code>n > 0</code> to produce <code>VERSION 3</code>.
    </p>

    <pre style="grid-column: content 2 / content 9;" class="prettyprint header">
        <code class="language-c" >
    // VERSION 3
    int logicalShift(int x, int n) {
        int negativeOne = ~0x0;
        int offset = (!n) + negativeOne;
        int thirtyOne = 0x1F;
        int needMask = ((x >> thirtyOne) & 0x1) & (!!n);
        int mask = (needMask << thirtyOne) >> (n + offset);
        return (x >> n) ^ mask;
    }
        </code>
    </pre>

    <p class="main"> 
    Let's try our example <code>logicalShift(0x80000000, 0)
    </code> one last time.
    </p>

    <figure  class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 2;" class="bin-caption">need mask?</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 2;" x="0x80000000" y="0x1F" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 5;" class="bin-caption">convert to bool</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 5;" x="0xFFFFFFFFF" y="0x1" op="&" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 8;" class="bin-caption">n > 0?</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 8;" x="0x1" y="0x0" op="&" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 11;" class="bin-caption">mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 11;" x="0x00000000" y="0x0" op=">>" >
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 14;" class="bin-caption">shift x</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 14;" x="0x80000000" y="0x0" op=">>">
        </op-2a-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 17;" class="bin-caption">apply mask</div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 17;" x="0x80000000" y="0x0" op="^">
        </op-2a-svg>
    </figure>

    <p class="main"> 
    We get what we expect. <code>VERSION 3</code> is indeed a solution.
    </p>

    <h1 style="grid-column: content 2 / content 6;" class="section-title"><a name="logicalShift">float_twice</a></h1>

    <h4 style="grid-column: content 2 / content 10;" >
      <span class="desc-title">Description</span></br>
      <span class="desc-info"><code>2*uf</code>, where <code>uf</code> is interpreted as IEEE <span class="num">754</span></span>
    </h4>

    <h4 style="grid-column: content 2 / content 10;" >
      <span class="desc-title">Legal Ops</span></br>
      <span class="desc-info">All integer ops and <code>||  &&  if  while</code>.</span>
    </h4>

    <h4 style="grid-column: content 2 / content 10;" >
      <span class="desc-title">Max ops</span></br>
      <span class="desc-info"><span class="num">30</span></span>
    </h4>

    <pre style="grid-column: content 2 / content 9;" class="prettyprint header">
        <code class="language-c" >
    import &ltassert.h&gt

    unsigned float_twice(unsigned uf) {
       //...
    }

    int main(int argc, char **argv) {
        assert(float_twice(0x0) == 0x0);                   
        assert(float_twice(0x80000000) == 0x80000000);
        assert(float_twice(0x800000) == 0x1000000);
        assert(float_twice(0x80800000) == 0x81000000);
        assert(float_twice(0x3f800000) == 0x40000000);
        assert(float_twice(0xbf800000) == 0xc0000000);
        assert(float_twice(0x3f800001) == 0x40000001);
        assert(float_twice(0x7f000000) == 0x7f800000);
        assert(float_twice(0xff000000) == 0xff800000);
        assert(float_twice(0x1) == 0x2);
        assert(float_twice(0x80000001) == 0x80000002);
        assert(float_twice(0x800001) == 0x1000001);
        assert(float_twice(0x80800001) == 0x81000001);
        assert(float_twice(0x807fffff) == 0x80fffffe);
        assert(float_twice(0x7fffffff) == 0xfffffffe);
        assert(float_twice(0x3f7fffff) == 0x3fffffff);

        return 0;
    }
        </code>
    </pre>

    <h2 style="grid-column: content 2 / content 10;" class="section-discussion">Floating Point Terminology</h2>

    <p class="main">
    A floating point value is calculated as
    <code>V = (-1)<sup>s</sup> * M * 2<sup>E</sup></code>, where <code>s</code>
    is the sign bit, <code>M</code> is the calculated mantissa, and  
    <code>E</code> is the calculated exponent. <code>e</code> will refer  
    to the bit representation of the exponent, and <code>m</code>
    will refer to the bit representation of the mantissa.
    </p>

    <p class="main">
    Here are several interesting test cases. The grey-bordered <code>MSB</code> is <code>s</code>,
    the green bits represent <code>e</code>, and the pink bits represent
    <code>m</code>.
    </p>

    <figure class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 3;" class="bin-caption">0x0</div> 
        <div style="grid-column: content 2 / content 10; grid-row: 2;" class="caption">Zero.</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 3;" hex="0x0" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 1 / content 2; grid-row: 6;" class="bin-caption">0x80000000</div> 
        <div style="grid-column: content 2 / content 10; grid-row: 5;" class="caption">Negative zero.</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 6;" hex="0x80000000" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 8;" class="caption">Smallest exponent for normalized values.</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 9;" class="bin-caption">0x800000</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 9;" hex="0x800000" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 11;" class="caption">Smallest exponent for normalized. (negative)</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 12;" class="bin-caption"><code class="aside">0x80800000</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 12;" hex="0x80800000" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 14;" class="caption">Exponent equals bias.</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 15;" class="bin-caption"><code class="aside">0x3F800000</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 15;" hex="0x3f800000" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 17;" class="caption">Exponent equals bias. (negative)</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 18;" class="bin-caption"><code class="aside">0xBF800000</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 18;" hex="0xbf800000" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 20;" class="caption">Exponent equals bias, smallest mantissa.</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 21;" class="bin-caption"><code class="aside">0x3F800001</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 21;" hex="0x3f800001" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 23;" class="caption">Largest exponent for normalized values.</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 24;" class="bin-caption"><code class="aside">0x7F000000</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 24;" hex="0x7f000000" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 26;" class="caption">Largest exponent for normalized values. (negative)</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 27;" class="bin-caption"><code class="aside">0xFF000000</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 27;" hex="0xff000000" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 29;" class="caption">Smallest non-zero Frac for denormalized values.</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 30;" class="bin-caption"><code class="aside">0x1</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 30;" hex="0x1" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 32;" class="caption">Smallest non-zero Frac for denormalized values. (negative)</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 33;" class="bin-caption"><code class="aside">0x80000001</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 33;" hex="0x80000001" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 35;" class="caption">Smallest exponent and mantissa for normalized values.</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 36;" class="bin-caption"><code class="aside">0x800001</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 36;" hex="0x800001" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 38;" class="caption">Smallest exponent and mantissa for normalized values. (negative)</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 39;" class="bin-caption"><code class="aside">0x80800001</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 39;" hex="0x80800001" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 41;" class="caption">Largest mantissa for denormalized values. (negative)</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 42;" class="bin-caption"><code class="aside">0x807FFFFF</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 42;" hex="0x807fffff" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 44;" class="caption">Largest NaN.</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 45;" class="bin-caption"><code class="aside">0x7FFFFFFF</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 45;" hex="0x7fffffff" isfloat="1">
        </bin-ary-svg>

        <div style="grid-column: content 2 / content 10; grid-row: 47;" class="caption">Exponent one less than bias, largest mantissa.</div> 
        <div style="grid-column: content 1 / content 2; grid-row: 48;" class="bin-caption"><code class="aside">0x3F7FFFFF</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 48;" hex="0x3f7fffff" isfloat="1">
        </bin-ary-svg>
    </figure>

    <h2 style="grid-column: content 2 / content 10;" class="section-discussion">Shift like Integers?</h2>

    <p class="main">
    Multiplication by powers of <span class="num">2</span> can be achieved on 
    two's complement and unsigned encodings
    with left shift. Does that work for floating point, i.e. will one left
    shift of a floating point number result in a multiplcation by 
    <span class="num">2</span>?
    </p>

    <p class="main">
    Let's start with a basic example. <code>1.5 * 2</code>.
    </p>

    <figure class="blend-bg">
        <div style="grid-column: content 2 / content 10; grid-row: 2;" class="caption">
        Observations: The exponent equals the bias, and the mantissa's 
        <code style="color: #a4b1b0;">MSB</code> is
        set.
        </div> 
        <div style="grid-column: content 1 / content 2; grid-row: 3;" class="bin-caption">1.5</div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 3;" hex="0x3fc00000" isfloat="1">
        </bin-ary-svg>
    </figure>

    <p class="main">
    <code>V = (-1)<sup>s</sup> * M * 2<sup>E</sup></code> 
    , and we want
    <code>2V = 2 * (-1)<sup>s</sup> * M * 2<sup>E</sup></code>, which 
    can be rewritten as
    <code>2V = (-1)<sup>s</sup> * M * 2<sup>(E + 1)</sup></code>. If we add one to 
    <code>e</code>, the result should be <code>1.5 * 2</code>.
    </p>

    <figure class="blend-bg">
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:2" x="0x3fc00000" y="0x00800000" op="+" isfloat="1" >
        </op-2a-svg>
    </figure>

    <p class="main">
    Is <code>0x40400000</code> the bit representation for <code>2 * 1.5</code>?
    If we plug in <code>s = 0x0</code>, <code>e = 0x80</code>, 
    and <code>m = 0x400000</code>, we get <code>
    V = (-1)<sup>0</sup> * (1.5) * 2<sup>1</sup></code>, which
    indeed is <code>2 * 1.5</code>.
    </p>

    <p class="main">
    That was a normalized value, let's see if adding one to <code>e</code>
    works for a denormalized value. Consider <code>0x00200000</code> interpreted
    as an IEEE <span class="num">754</span>.
    </p>

    <figure class="blend-bg">
        <div style="grid-column: content 1 / content 2; grid-row: 3;" class="bin-caption"><code class="aside">0x00200000</code></div> 
        <bin-ary-svg style="grid-column: content 2 / content 10; grid-row: 3;" hex="0x00200000" isfloat="1">
        </bin-ary-svg>
    </figure>

    <p class="main">
    The value for <code>0x00200000</code> is <code>V = (-1)<sup>0</sup> * (1/4)
    * 2<sup>-126</sup></code>. If we add one to <code>e</code> as we did 
    in the normalized case, we can rewrite the value as
    <code>2V = (-1)<sup>0</sup> * (1/4) * 2<sup>-125</sup></code>. Is that a 
    valid operation?
    </p>

    <p class="main">
    Not for a denomalized value, because <code>E = 1 - bias</code>, which is a 
    constant. Adding one to <code>e</code> converts
    the number to a normalized value. 
    </p>

    <figure class="blend-bg">
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:2" x="0x00200000" y="0x00800000" op="+" isfloat="1" >
        </op-2a-svg>
    </figure>

    <p class="main">
    The result interpreted as a normalized value 
    <code>V = (-1)<sup>0</sup> * (5/4) * 2<sup>-125</sup></code> is incorrect. 
    </p>

    <p class="main">
    What if we apply the factor of <span class="num">2</span> to a different part
    of our representation, namely the mantissa? So we have instead
    <code>2V = (-1)<sup>0</sup> * (2/4) * 2<sup>-126</sup></code>, which would be the
    equivalent of performing a left shift on <code>m</code>.
    </p>

    <figure class="blend-bg">
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row:2" x="0x00200000" y="0x00000001" op="<<" isfloat="1" >
        </op-2a-svg>
    </figure>

    <p class="main">
    Different operations need to be performed depending on whether the
    type of input is normalized or denormalized. 
    </p>

    <p class="main">
    We're still not at a solution. If the <code>MSB</code> of <code>m</code>
    is set, <code>m</code> overflows into <code>e</code>. Consider 
    <code>0x00400000</code>.
    </p>

    <figure class="blend-bg">
        <div style="grid-column: content 2 / content 10; grid-row: 2;" class="caption">
        Observations: A left shift results in an overflow of the mantissa.
        </div> 
        <op-2a-svg style="grid-column: content 2 / content 10; grid-row: 3;" x="0x00400000" y="0x00000001" op="<<" isfloat="1" >
        </op-2a-svg>
    </figure>

    <p class="main">
    We want to rollover the factor of two from the mantissa to the exponent,
    so we truncate <code>m</code> and add one to <code>e</code>. 
    </p>

    <p class="main">
    The answer to "Shift like Integers?" is, "It depends." 
    </p>

    <pre style="grid-column: content 2 / content 9;" class="prettyprint header">
            <code class="language-c" >
    unsigned float_twice(unsigned uf) {
        unsigned expMask = 0x7f800000;
        unsigned fracMask = 0x007FFFFF;

        /* handle NaN */
        unsigned isSpecial = (expMask & uf) == expMask;
        unsigned noFrac = !(fracMask & uf);
        if (isSpecial) return uf;

        /* extract each part of the float */
        unsigned exp = (expMask & uf) >> 23;
        unsigned frac = fracMask & uf;
        unsigned sign = (1 << 31) & uf; 

        /* normalized vs. denormalized */
        if (exp) {
            exp += 1;
        } else {
            frac <<=1;
        }

        /* check if frac needs to be rounded up */
        unsigned frac_needs_rounding = ((1 << 23) & frac) >> 23;

        /* rollover factor to exponent */
        exp = frac_needs_rounding ? exp + 1 : exp;

        return sign | (exp << 23) | frac;
    }
    </code>
    </pre>

    <script >
    "use strict";function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj}}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj}}return _typeof(obj)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function")}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor}function _possibleConstructorReturn(self,call){if(call&&(_typeof(call)==="object"||typeof call==="function")){return call}return _assertThisInitialized(self)}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}return self}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function")}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:true,configurable:true}});if(superClass)_setPrototypeOf(subClass,superClass)}function _wrapNativeSuper(Class){var _cache=typeof Map==="function"?new Map:undefined;_wrapNativeSuper=function _wrapNativeSuper(Class){if(Class===null||!_isNativeFunction(Class))return Class;if(typeof Class!=="function"){throw new TypeError("Super expression must either be null or a function")}if(typeof _cache!=="undefined"){if(_cache.has(Class))return _cache.get(Class);_cache.set(Class,Wrapper)}function Wrapper(){return _construct(Class,arguments,_getPrototypeOf(this).constructor)}Wrapper.prototype=Object.create(Class.prototype,{constructor:{value:Wrapper,enumerable:false,writable:true,configurable:true}});return _setPrototypeOf(Wrapper,Class)};return _wrapNativeSuper(Class)}function isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true}catch(e){return false}}function _construct(Parent,args,Class){if(isNativeReflectConstruct()){_construct=Reflect.construct}else{_construct=function _construct(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a);var instance=new Constructor;if(Class)_setPrototypeOf(instance,Class.prototype);return instance}}return _construct.apply(null,arguments)}function _isNativeFunction(fn){return Function.toString.call(fn).indexOf("[native code]")!==-1}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o};return _setPrototypeOf(o,p)}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o)}var BinarySVG=function(_HTMLElement){_inherits(BinarySVG,_HTMLElement);function BinarySVG(){var _this;_classCallCheck(this,BinarySVG);_this=_possibleConstructorReturn(this,_getPrototypeOf(BinarySVG).call(this));_this.BITS=32;_this.BIT_MAX_INDEX=31;_this.RECT_WIDTH=17;_this.RECT_HEIGHT=20;_this.RECT_GUTTER=2;_this.SVG_NS="http://www.w3.org/2000/svg";_this.SVG_HEIGHT=_this.RECT_HEIGHT;_this.SVG_WIDTH=_this.BITS*_this.RECT_WIDTH+(_this.BITS-1)*_this.RECT_GUTTER;_this.container=document.createElementNS(_this.SVG_NS,"svg");_this.container.setAttribute("width",_this.SVG_WIDTH);_this.container.setAttribute("height",_this.SVG_HEIGHT);_this.render();return _this}_createClass(BinarySVG,[{key:"render",value:function render(){if(parseInt(this.getAttribute("isfloat"),2)){this.renderFloat()}else{this.renderTwoCompSVG()}}},{key:"renderTwoCompSVG",value:function renderTwoCompSVG(){var hex=this.getAttribute("hex");var hi=this.getAttribute("hi");var binarray=hexStringToArray(hex);var hibinarray=hi?hiliteArrayFromHex(hi):new Array(32).fill(0);var offset=this.BIT_MAX_INDEX-binarray.length;var i,x,y,bit_group,bit_rect,bit_text,ishi;for(i=this.BIT_MAX_INDEX;i>offset;i--){x=i*(this.RECT_WIDTH+this.RECT_GUTTER);y=0;bit_group=document.createElementNS(this.SVG_NS,"g");bit_group.setAttribute("transform","translate(".concat(x,", ").concat(y,")"));bit_group.style="font-family: input;";bit_rect=document.createElementNS(this.SVG_NS,"rect");bit_rect.setAttribute("rx",2);bit_rect.setAttribute("ry",2);bit_text=document.createElementNS(this.SVG_NS,"text");bit_text.innerHTML=binarray[i-offset-1];ishi=hibinarray[i];if(ishi){bit_rect.setAttribute("width",this.RECT_WIDTH-1);bit_rect.setAttribute("height",this.RECT_HEIGHT-1);bit_rect.setAttribute("stroke-weight",1);bit_rect.setAttribute("stroke","#545454");bit_rect.setAttribute("fill","#DAEA4D");bit_rect.setAttribute("x",.5);bit_rect.setAttribute("y",.5);bit_text.setAttribute("fill","#545454");bit_text.setAttribute("y",16);bit_text.setAttribute("x",4)}else{bit_rect.setAttribute("width",this.RECT_WIDTH);bit_rect.setAttribute("height",this.RECT_HEIGHT);bit_rect.setAttribute("fill","#CADCF6");bit_text.setAttribute("fill","#407CD2");bit_text.setAttribute("y",16);bit_text.setAttribute("x",4)}bit_group.append(bit_rect);bit_group.append(bit_text);this.container.append(bit_group)}if(i>=0)for(;i>=0;i--){x=i*(this.RECT_WIDTH+this.RECT_GUTTER);y=0;bit_group=document.createElementNS(this.SVG_NS,"g");bit_group.setAttribute("transform","translate(".concat(x,", ").concat(y,")"));bit_group.style="font-family: input;";bit_rect=document.createElementNS(this.SVG_NS,"rect");bit_rect.setAttribute("rx",2);bit_rect.setAttribute("ry",2);bit_text=document.createElementNS(this.SVG_NS,"text");bit_text.setAttribute("y",16);bit_text.setAttribute("x",4);bit_text.innerHTML="0";ishi=hibinarray[i];if(ishi){bit_rect.setAttribute("width",this.RECT_WIDTH-1);bit_rect.setAttribute("height",this.RECT_HEIGHT-1);bit_rect.setAttribute("stroke-weight",1);bit_rect.setAttribute("stroke","#545454");bit_rect.setAttribute("fill","#DAEA4D");bit_rect.setAttribute("x",.5);bit_rect.setAttribute("y",.5);bit_text.setAttribute("fill","#545454");bit_text.setAttribute("y",16);bit_text.setAttribute("x",4)}else{bit_rect.setAttribute("width",this.RECT_WIDTH);bit_rect.setAttribute("height",this.RECT_HEIGHT);bit_rect.setAttribute("fill","#f5f5f5");bit_text.setAttribute("fill","#e8e8ed")}bit_group.append(bit_rect);bit_group.append(bit_text);this.container.append(bit_group)}this.append(this.container)}},{key:"renderFloat",value:function renderFloat(){var hex=this.getAttribute("hex");var hi=this.getAttribute("hi");var fbinarray=hexStringToArray(hex);var len=fbinarray.length;fbinarray=len<32?new Array(32-len).fill(0).concat(fbinarray):fbinarray;var hibinarray=hi?hiliteArrayFromHex(hi):new Array(32).fill(0);var mask=255;var exp=parseInt(hex,16)>>>23&mask;if(exp==mask){var i,x,y,bit_group,bit_rect,bit_text,ishi;for(i=0;i<32;i++){x=i*(this.RECT_WIDTH+this.RECT_GUTTER);y=0;ishi=hibinarray[i];bit_group=document.createElementNS(this.SVG_NS,"g");bit_group.setAttribute("transform","translate(".concat(x,", ").concat(y,")"));bit_group.style="font-family: input;";bit_rect=document.createElementNS(this.SVG_NS,"rect");bit_rect.setAttribute("rx",2);bit_rect.setAttribute("ry",2);bit_text=document.createElementNS(this.SVG_NS,"text");bit_text.setAttribute("y",16);bit_text.setAttribute("x",4);bit_text.innerHTML=fbinarray[i];if(ishi){bit_rect.setAttribute("width",this.RECT_WIDTH-1);bit_rect.setAttribute("height",this.RECT_HEIGHT-1);bit_rect.setAttribute("stroke-weight",1);bit_rect.setAttribute("stroke","#545454");bit_rect.setAttribute("fill","#DAEA4D");bit_rect.setAttribute("x",.5);bit_rect.setAttribute("y",.5);bit_text.setAttribute("fill","#545454")}else if(i==0||i>8){bit_rect.setAttribute("width",this.RECT_WIDTH);bit_rect.setAttribute("height",this.RECT_HEIGHT);bit_rect.setAttribute("fill","#f5f5f5");bit_text.setAttribute("fill","#e8e8ed")}else{bit_rect.setAttribute("width",this.RECT_WIDTH-1);bit_rect.setAttribute("height",this.RECT_HEIGHT-1);bit_rect.setAttribute("stroke-width",1);bit_rect.setAttribute("x",.5);bit_rect.setAttribute("y",.5);bit_rect.setAttribute("stroke","#DF3232");bit_rect.setAttribute("fill","#fff");bit_text.setAttribute("fill","#b36363")}bit_group.append(bit_rect);bit_group.append(bit_text);this.container.append(bit_group)}}else{var _i,_x,_y,_bit_group,_bit_rect,_bit_text,_ishi;for(_i=0;_i<32;_i++){_x=_i*(this.RECT_WIDTH+this.RECT_GUTTER);_y=0;_ishi=hibinarray[_i];_bit_group=document.createElementNS(this.SVG_NS,"g");_bit_group.setAttribute("transform","translate(".concat(_x,", ").concat(_y,")"));_bit_group.style="font-family: input;";_bit_rect=document.createElementNS(this.SVG_NS,"rect");_bit_rect.setAttribute("width",this.RECT_WIDTH);_bit_rect.setAttribute("height",this.RECT_HEIGHT);_bit_rect.setAttribute("stroke-width",1);_bit_rect.setAttribute("rx",2);_bit_rect.setAttribute("ry",2);_bit_text=document.createElementNS(this.SVG_NS,"text");_bit_text.setAttribute("y",16);_bit_text.setAttribute("x",4);_bit_text.innerHTML=fbinarray[_i];if(_ishi){_bit_rect.setAttribute("width",this.RECT_WIDTH-1);_bit_rect.setAttribute("height",this.RECT_HEIGHT-1);_bit_rect.setAttribute("stroke-weight",1);_bit_rect.setAttribute("stroke","#545454");_bit_rect.setAttribute("fill","#DAEA4D");_bit_rect.setAttribute("x",.5);_bit_rect.setAttribute("y",.5);_bit_text.setAttribute("fill","#545454")}else if(_i==0){_bit_rect.setAttribute("x",.5);_bit_rect.setAttribute("width",this.RECT_WIDTH-1);_bit_rect.setAttribute("stroke","#888");_bit_rect.setAttribute("fill","#fff");_bit_text.setAttribute("fill","#888")}else if(_i>0&&_i<9){_bit_rect.setAttribute("fill","#C0DC93");_bit_text.setAttribute("fill","#84A739")}else{_bit_rect.setAttribute("fill","#DE74AE");_bit_text.setAttribute("fill","#B1397B")}_bit_group.append(_bit_rect);_bit_group.append(_bit_text);this.container.append(_bit_group)}}this.append(this.container)}}]);return BinarySVG}(_wrapNativeSuper(HTMLElement));function hexStringToArray(x){return(parseInt(x,16)>>>0).toString(2).split("")}function arithMask(x,shift){if(shift==32)return console.error("shift of size equal to sizeof datatype is undefined"),x;return~((1<<31-shift)-1>>>0)}function hiliteArrayFromHex(x){var bools=hexStringToArray(x).map(function(d){return parseInt(d,2)});bools=new Array(32-bools.length).fill(0).concat(bools);return bools}var EqualsBar=function(_HTMLElement2){_inherits(EqualsBar,_HTMLElement2);function EqualsBar(){var _this2;_classCallCheck(this,EqualsBar);_this2=_possibleConstructorReturn(this,_getPrototypeOf(EqualsBar).call(this));var style="grid-column: 1 / 33;";_this2.innerHTML='<div style="'.concat(style,'" class="bar"></div>');return _this2}return EqualsBar}(_wrapNativeSuper(HTMLElement));var Operator2asvg=function(_HTMLElement3){_inherits(Operator2asvg,_HTMLElement3);function Operator2asvg(){var _this3;_classCallCheck(this,Operator2asvg);_this3=_possibleConstructorReturn(this,_getPrototypeOf(Operator2asvg).call(this));var binary_width=608;var binary_height=22;_this3.style.display="grid";_this3.style.gridTemplateColumns="".concat(binary_width,"px auto");_this3.style.gridTemplateRows="".concat(binary_height,"px ").concat(binary_height,"px 6px ").concat(binary_height,"px");var op=_this3.getAttribute("op");var x=_this3.getAttribute("x");var y=_this3.getAttribute("y");var isfloat=parseInt(_this3.getAttribute("isfloat"),2);var hix=_this3.getAttribute("hix");var hiy=_this3.getAttribute("hiy");var hires=_this3.getAttribute("hires");var res;switch(op){case"|":{res=parseInt(x,16)|parseInt(y,16);break}case"^":{res=parseInt(x,16)^parseInt(y,16);break}case"&":{res=parseInt(x,16)&parseInt(y,16);break}case"+":{res=parseInt(x,16)+parseInt(y,16);break}case">>":{res=parseInt(x,16)>>parseInt(y,16);break}case"<<":{res=parseInt(x,16)<<parseInt(y,16);break}default:res=NaN}if(res<0&&res>1<<31){var mask=arithMask(parseInt(x,16),parseInt(y,16));res=(res|mask)>>>0}else res=res>>>0;_this3.innerHTML='\n        <bin-ary-svg style="grid-row: 1; grid-column: 1;" hex="'.concat(x,'" isfloat="').concat(isfloat,'" hi="').concat(hix,'"></bin-ary-svg>\n        <bin-ary-svg style="grid-row: 2; grid-column: 1;" hex="').concat(y,'" isfloat="0" hi="').concat(hiy,'"></bin-ary-svg>\n        <op-shape style="grid-row: 1; grid-column: 2;" op="').concat(op,'"></op-shape>\n        <eq-bar style="grid-row:3; grid-column: 1;"></eq-bar>\n        <bin-ary-svg style="grid-row:4; grid-column: 1;" hex="0x').concat(res.toString(16),'" hi="').concat(hires,'" isfloat="').concat(isfloat,'"></bin-ary-svg>\n        ');return _this3}_createClass(Operator2asvg,[{key:"connectedCallback",value:function connectedCallback(){var nodes=this.querySelectorAll("bin-ary-svg");nodes[1].classList.add("bottom");nodes[2].classList.add("result")}}]);return Operator2asvg}(_wrapNativeSuper(HTMLElement));var Opshape=function(_HTMLElement4){_inherits(Opshape,_HTMLElement4);function Opshape(){var _this4;_classCallCheck(this,Opshape);_this4=_possibleConstructorReturn(this,_getPrototypeOf(Opshape).call(this));_this4.shapes={};_this4.shapes["plus"]=plus;_this4.shapes["and"]=and;_this4.shapes["or"]=or;_this4.shapes["xor"]=xor;_this4.shapes["rightshift"]=rightshift;_this4.shapes["leftshift"]=leftshift;_this4.shapes["invert"]=invert;_this4.shapes["not"]=not;var op=_this4.getAttribute("op");switch(op){case"+":{_this4.innerHTML=_this4.shapes.plus;break}case"&":{_this4.innerHTML=_this4.shapes.and;break}case"~":{_this4.innerHTML=_this4.shapes.invert;break}case"!":{_this4.innerHTML=_this4.shapes.not;break}case"|":{_this4.innerHTML=_this4.shapes.or;break}case"^":{_this4.innerHTML=_this4.shapes.xor;break}case">>":{_this4.innerHTML=_this4.shapes.rightshift;break}case"<<":{_this4.innerHTML=_this4.shapes.leftshift;break}}return _this4}return Opshape}(_wrapNativeSuper(HTMLElement));var plus='\n<svg width="44px" height="41px" viewBox="0 0 44 41" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <defs></defs>\n    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g transform="translate(-756.000000, -566.000000)">\n            <g transform="translate(756.000000, 566.000000)">\n                <rect fill="#DAD3D3" x="0" y="0" width="44" height="41"></rect>\n                <polygon fill="#9A877E" points="19.9393939 29 19.9393939 21.5443038 14 21.5443038 14 17.4556962 19.9393939 17.4556962 19.9393939 10 24.0606061 10 24.0606061 17.4556962 30 17.4556962 30 21.5443038 24.0606061 21.5443038 24.0606061 29"></polygon>\n            </g>\n        </g>\n    </g>\n</svg>\n';var leftshift='\n<svg width="44px" height="41px" viewBox="0 0 44 41" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g transform="translate(-648.000000, -567.000000)">\n            <g transform="translate(648.000000, 567.000000)">\n                <rect fill="#DAD3D3" transform="translate(22.000000, 20.500000) scale(-1, 1) translate(-22.000000, -20.500000) " x="0" y="0" width="44" height="41"></rect>\n                <path d="M8.38095238,16.6480423 L8.38095238,12.9473684 L20.4028819,17.9824861 L20.4028819,21.1053596 L8.38095238,26.1542345 L8.38095238,22.4398034 L16.0349141,19.7984302 L16.8497338,19.5232871 L16.0482718,19.2481441 L8.38095238,16.6480423 Z M22.9634314,16.6480423 L22.9634314,12.9473684 L34.9853608,17.9824861 L34.9853608,21.1053596 L22.9634314,26.1542345 L22.9634314,22.4398034 L30.6173931,19.7984302 L31.4322128,19.5232871 L30.6307508,19.2481441 L22.9634314,16.6480423 Z" id="&gt;&gt;" fill="#9A877E" transform="translate(21.683157, 19.550801) scale(-1, 1) translate(-21.683157, -19.550801) "></path>\n            </g>\n        </g>\n    </g>\n</svg>\n';var rightshift='\n<svg width="44px" height="41px" viewBox="0 0 44 41" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g transform="translate(-699.000000, -566.000000)">\n            <g transform="translate(699.000000, 566.000000)">\n                <rect fill="#DAD3D3" x="0" y="0" width="44" height="41"></rect>\n                <path d="M8.38095238,16.6480423 L8.38095238,12.9473684 L20.4028819,17.9824861 L20.4028819,21.1053596 L8.38095238,26.1542345 L8.38095238,22.4398034 L16.0349141,19.7984302 L16.8497338,19.5232871 L16.0482718,19.2481441 L8.38095238,16.6480423 Z M22.9634314,16.6480423 L22.9634314,12.9473684 L34.9853608,17.9824861 L34.9853608,21.1053596 L22.9634314,26.1542345 L22.9634314,22.4398034 L30.6173931,19.7984302 L31.4322128,19.5232871 L30.6307508,19.2481441 L22.9634314,16.6480423 Z" id="&gt;&gt;" fill="#9A877E"></path>\n            </g>\n        </g>\n    </g>\n</svg>\n';var not='\n<svg width="44px" height="41px" viewBox="0 0 44 41" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g transform="translate(-482.000000, -568.000000)">\n            <g transform="translate(482.000000, 568.000000)">\n                <rect fill="#DAD3D3" x="0" y="0" width="44" height="41"></rect>\n                <path d="M22.9964658,22.6009971 L19.3727679,22.6009971 L19.1436012,8.63157895 L23.2256324,8.63157895 L22.9964658,22.6009971 Z M18.8571429,28.1032072 C18.8571429,27.7786785 18.9096597,27.4787397 19.0146949,27.203382 C19.1197302,26.9280243 19.2725064,26.6870898 19.4730283,26.4805715 C19.6735501,26.2740532 19.9170373,26.1142498 20.203497,26.0011565 C20.4899568,25.8880631 20.8146063,25.8315173 21.1774554,25.8315173 C21.5307557,25.8315173 21.850631,25.8880631 22.1370908,26.0011565 C22.4235505,26.1142498 22.6670377,26.2740532 22.8675595,26.4805715 C23.0680814,26.6870898 23.2232447,26.9280243 23.3330543,27.203382 C23.4428639,27.4787397 23.4977679,27.7786785 23.4977679,28.1032072 C23.4977679,28.4179018 23.4428639,28.7129235 23.3330543,28.9882813 C23.2232447,29.263639 23.0680814,29.4996564 22.8675595,29.6963405 C22.6670377,29.8930246 22.4235505,30.047911 22.1370908,30.1610043 C21.850631,30.2740977 21.5307557,30.3306435 21.1774554,30.3306435 C20.8146063,30.3306435 20.4899568,30.2740977 20.203497,30.1610043 C19.9170373,30.047911 19.6735501,29.8930246 19.4730283,29.6963405 C19.2725064,29.4996564 19.1197302,29.263639 19.0146949,28.9882813 C18.9096597,28.7129235 18.8571429,28.4179018 18.8571429,28.1032072 Z" id="!" fill="#9A877E"></path>\n            </g>\n        </g>\n    </g>\n</svg>\n';var or='\n<svg width="44px" height="41px" viewBox="0 0 44 41" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g transform="translate(-593.000000, -568.000000)">\n            <g transform="translate(593.000000, 568.000000)">\n                <rect fill="#DAD3D3" x="0" y="0" width="44" height="41"></rect>\n                <polygon fill="#9A877E" points="23.8648725 34.5258018 20 34.5258018 20 7 23.8648725 7"></polygon>\n            </g>\n        </g>\n    </g>\n</svg>\n';var xor='\n<svg width="44px" height="41px" viewBox="0 0 44 41" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <defs></defs>\n    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g transform="translate(-420.000000, -567.000000)">\n            <g transform="translate(420.000000, 567.000000)">\n                <rect fill="#DAD3D3" x="0" y="0" width="44" height="41"></rect>\n                <polygon id="^" fill="#9A897E" points="18.3316925 25.905794 14.6666667 25.905794 19.8860562 12.9473684 23.1747624 12.9473684 28.3777902 25.905794 24.729126 25.905794 21.8494629 18.2554361 21.5058667 16.8399514 21.1622705 18.2554361"></polygon>\n            </g>\n        </g>\n    </g>\n</svg>\n';var invert='\n<svg width="44px" height="41px" viewBox="0 0 44 41" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g transform="translate(-535.000000, -568.000000)">\n            <g transform="translate(535.000000, 568.000000)">\n                <rect fill="#DAD3D3" x="0" y="0" width="44" height="41"></rect>\n                <path d="M30.6796875,18.3252467 C30.6796875,19.1218173 30.5722667,19.8593716 30.3574219,20.5379317 C30.1425771,21.2164919 29.8417988,21.7991598 29.4550781,22.2859529 C29.0683574,22.7727461 28.6028673,23.1538158 28.0585938,23.4291735 C27.5143202,23.7045313 26.917538,23.8422081 26.2682292,23.8422081 C25.8480882,23.8422081 25.4542119,23.8028718 25.0865885,23.7241982 C24.7189652,23.6455246 24.3585087,23.5250573 24.0052083,23.362793 C23.651908,23.2005286 23.3033871,22.9964719 22.9596354,22.7506168 C22.6158837,22.5047617 22.2625886,22.2097399 21.8997396,21.8655428 C21.4318553,21.4721746 20.9830751,21.1673188 20.5533854,20.9509663 C20.1236958,20.7346138 19.684464,20.6264391 19.2356771,20.6264391 C18.9778633,20.6264391 18.7296019,20.692819 18.4908854,20.8255808 C18.2521689,20.9583426 18.0397145,21.1353556 17.8535156,21.3566252 C17.6673168,21.5778948 17.5193148,21.8311218 17.4095052,22.1163137 C17.2996956,22.4015057 17.2447917,22.6965274 17.2447917,23.0013877 L14.6666667,22.6768606 C14.6666667,21.88029 14.7717003,21.1501113 14.9817708,20.4863024 C15.1918413,19.8224936 15.4902324,19.2521183 15.8769531,18.7751593 C16.2636738,18.2982004 16.7267768,17.9269647 17.266276,17.6614412 C17.8057753,17.3959177 18.4001704,17.2631579 19.0494792,17.2631579 C19.8802125,17.2631579 20.6464809,17.4303369 21.3483073,17.7646998 C22.0501337,18.0990628 22.7543367,18.5858486 23.4609375,19.225072 C23.9288218,19.6381086 24.3752149,19.9478814 24.8001302,20.1543997 C25.2250455,20.360918 25.6523416,20.4641756 26.0820312,20.4641756 C26.339845,20.4641756 26.5833322,20.3953372 26.8125,20.2576583 C27.0416678,20.1199794 27.2421866,19.9380494 27.4140625,19.7118627 C27.5859384,19.485676 27.7243918,19.2275319 27.8294271,18.9374229 C27.9344623,18.6473139 27.9869792,18.3498336 27.9869792,18.0449733 L30.6796875,18.3252467 Z" id="~" fill="#9A877E"></path>\n            </g>\n        </g>\n    </g>\n</svg>\n';var and='\n<svg width="44px" height="41px" viewBox="0 0 44 41" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g transform="translate(-342.000000, -567.000000)">\n            <g transform="translate(342.000000, 567.000000)">\n                <g fill="#DAD3D3">\n                    <rect x="0" y="0" width="44" height="41"></rect>\n                </g>\n                <path d="M16,24.1807553 C16,23.7359491 16.0623393,23.3282162 16.1870199,22.9575443 C16.3117004,22.5868724 16.4886093,22.2414788 16.7177519,21.9213531 C16.9468945,21.6012274 17.2215246,21.2996399 17.5416503,21.0165814 C17.861776,20.7335228 18.2206483,20.4538383 18.6182781,20.1775192 C18.2206483,19.5777048 17.9123214,19.0099114 17.693288,18.4741221 C17.4742546,17.9383327 17.3647396,17.3840181 17.3647396,16.8111616 C17.3647396,16.2315656 17.4574061,15.7058934 17.6427421,15.2341292 C17.828078,14.762365 18.092599,14.3613715 18.4363129,14.0311366 C18.7800268,13.7009016 19.1944991,13.4464898 19.6797423,13.2678933 C20.1649854,13.0892969 20.7075061,13 21.3073206,13 C21.8127822,13 22.2727454,13.0909817 22.6872239,13.2729479 C23.1017025,13.4549141 23.4555203,13.7025866 23.748688,14.0159728 C24.0418558,14.329359 24.2693101,14.6916011 24.4310578,15.1027099 C24.5928055,15.5138187 24.6736782,15.9485091 24.6736782,16.4067943 C24.6736782,16.7505083 24.6197631,17.0739988 24.5119313,17.3772758 C24.4040995,17.6805528 24.2558329,17.9652919 24.0671273,18.2315017 C23.8784216,18.4977115 23.6577067,18.7487537 23.4049758,18.9846358 C23.152245,19.2205179 22.8809847,19.4429176 22.5911867,19.6518418 L21.7824521,20.3089386 L24.2794201,23.5135493 C24.4950837,23.1293985 24.6618836,22.7081868 24.7798246,22.2499016 C24.8977656,21.7916164 24.9567353,21.2996411 24.9567353,20.773961 L27.3627206,20.773961 C27.3627206,21.6972709 27.2397268,22.5582276 26.9937355,23.356857 C26.7477441,24.1554864 26.3619142,24.8715463 25.8362341,25.5050582 L27.7367603,27.9312619 L24.5220405,27.9312619 L23.8649436,27.0921998 C23.3527425,27.4359137 22.8220158,27.6970649 22.2727475,27.8756614 C21.7234791,28.0542578 21.1017707,28.1435547 20.4076034,28.1435547 C19.726915,28.1435547 19.1136308,28.0458336 18.5677322,27.8503884 C18.0218337,27.6549432 17.5585008,27.3819981 17.1777197,27.0315447 C16.7969386,26.6810913 16.5054601,26.2632493 16.3032755,25.7780061 C16.1010908,25.2927629 16,24.7603513 16,24.1807553 Z M20.5289136,25.8892071 C20.8793669,25.8892071 21.2230757,25.8420314 21.5600501,25.7476785 C21.8970245,25.6533257 22.2205151,25.518538 22.5305316,25.3433113 L19.8718167,21.885971 L19.7909433,21.9466261 C19.5887586,22.1420713 19.4236436,22.3341438 19.2955933,22.5228495 C19.1675431,22.7115552 19.0681371,22.8935186 18.9973725,23.0687453 C18.9266078,23.243972 18.8794321,23.4107718 18.8558439,23.5691498 C18.8322557,23.7275278 18.8204618,23.8774792 18.8204618,24.0190084 C18.8204618,24.288588 18.8608981,24.5379453 18.941772,24.7670879 C19.0226458,24.9962305 19.1372154,25.1933576 19.2854842,25.358475 C19.4337529,25.5235925 19.6140315,25.6533257 19.8263254,25.7476785 C20.0386193,25.8420314 20.272813,25.8892071 20.5289136,25.8892071 Z M19.9122534,16.8111616 C19.9122534,17.1144386 19.9745928,17.4193959 20.0992733,17.7260426 C20.2239539,18.0326893 20.3941234,18.3578648 20.609787,18.7015787 L21.5499409,18.0040451 C21.7588651,17.8692553 21.9172407,17.7294131 22.0250725,17.5845141 C22.1329043,17.4396151 22.2087224,17.3014576 22.2525291,17.1700376 C22.2963358,17.0386176 22.3182388,16.9206783 22.3182388,16.8162162 C22.3182388,16.7117541 22.3182388,16.6291967 22.3182388,16.5685413 C22.3182388,16.4067935 22.2946509,16.2484179 22.2474745,16.0934097 C22.2002981,15.9384015 22.1329042,15.800244 22.0452909,15.6789332 C21.9576775,15.5576224 21.8515322,15.4599013 21.7268516,15.385767 C21.6021711,15.3116326 21.4623288,15.274566 21.3073206,15.274566 C21.0714385,15.274566 20.8658872,15.3150023 20.6906605,15.3958761 C20.5154338,15.47675 20.3705369,15.5879499 20.2559656,15.7294791 C20.1413943,15.8710084 20.0554671,16.0344385 19.9981815,16.2197745 C19.9408958,16.4051104 19.9122534,16.6022375 19.9122534,16.8111616 Z" fill="#9A897E"></path>\n            </g>\n        </g>\n    </g>\n</svg>\n';var main=function main(){customElements.define("op-2a-svg",Operator2asvg);customElements.define("bin-ary-svg",BinarySVG);customElements.define("eq-bar",EqualsBar);customElements.define("op-shape",Opshape)};main();
    </script>
</body>
</html>
